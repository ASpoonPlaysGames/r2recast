//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

#define DT_VERTS_PER_POLYGON 6

typedef unsigned int dtTileRef;
typedef unsigned int dtPolyRef;

struct dtNavMeshParams
{
	float orig[3];					///< The world space origin of the navigation mesh's tile space. [(x, y, z)]
	float tileWidth;				///< The width of each tile. (Along the x-axis.)
	float tileHeight;				///< The height of each tile. (Along the z-axis.)
	int maxTiles;					///< The maximum number of tiles the navigation mesh can contain. This and maxPolys are used to calculate how many bits are needed to identify tiles and polygons uniquely.
	int maxPolys;					///< The maximum number of polygons each tile can contain. This and maxTiles are used to calculate how many bits are needed to identify tiles and polygons uniquely.

	int disjoint_poly_group_count;
	int reachability_table_size;
	int reachability_table_count;

};

struct NavMeshSetHeader {
    char magic[4];
    int version;
    int numTiles;
    dtNavMeshParams params;
};

struct dtMeshHeader
{
	char magic[4];				///< Tile magic number. (Used to identify the data format.)

	int version;			///< Tile data format version number.
	int x;					///< The x-position of the tile within the dtNavMesh tile grid. (x, y, layer)
	int y;					///< The y-position of the tile within the dtNavMesh tile grid. (x, y, layer)
	int layer;				///< The layer of the tile within the dtNavMesh tile grid. (x, y, layer)
	unsigned int userId;	///< The user defined id of the tile.
	int polyCount;			///< The number of polygons in the tile.
	int sth_per_poly;
	int vertCount;			///< The number of vertices in the tile.
	int maxLinkCount;		///< The number of allocated links.

	int detailMeshCount;
	
	/// The number of unique vertices in the detail mesh. (In addition to the polygon vertices.)
	int detailVertCount;
	
	int detailTriCount;			///< The number of triangles in the detail mesh.
	int bvNodeCount;			///< The number of bounding volume nodes. (Zero if bounding volumes are disabled.)
	int offMeshConCount;		///< The number of off-mesh connections.
	//int unk1;
	int offMeshBase;			///< The index of the first polygon which is an off-mesh connection.

	float walkableHeight;		///< The height of the agents using the tile.
	float walkableRadius;		///< The radius of the agents using the tile.
	float walkableClimb;		///< The maximum climb height of the agents using the tile.
	float bmin[3];				///< The minimum bounds of the tile's AABB. [(x, y, z)]
	float bmax[3];				///< The maximum bounds of the tile's AABB. [(x, y, z)]
	
	/// The bounding volume quantization factor. 
	float bvQuantFactor;

    
};

struct dtPoly
{
	/// Index to first link in linked list. (Or #DT_NULL_LINK if there is no link.)
	unsigned int firstLink;

	/// The indices of the polygon's vertices.
	/// The actual vertices are located in dtMeshTile::verts.
	unsigned short verts[DT_VERTS_PER_POLYGON];

	/// Packed data representing neighbor polygons references and flags for each edge.
	unsigned short neis[DT_VERTS_PER_POLYGON];

	/// The user defined polygon flags.
	unsigned short flags;

	/// The number of vertices in the polygon.
	unsigned char vertCount;

	/// The bit packed area id and polygon type.
	/// @note Use the structure's set and get methods to acess this value.
	unsigned char areaAndtype;

	unsigned short link_table_idx;						//IDK but looks filled
	unsigned short unk;						//IDK but looks filled
	float org[3];					//NO IDEA
};

struct dtLink
{
	dtPolyRef ref;					///< Neighbour reference. (The neighbor that is linked to.)
	unsigned int next;				///< Index of the next link.
	unsigned char edge;				///< Index of the polygon edge that owns this link.
	unsigned char side;				///< If a boundary link, defines on which side the link is.
	unsigned char bmin;				///< If a boundary link, defines the minimum sub-edge area.
	unsigned char bmax;				///< If a boundary link, defines the maximum sub-edge area.
	unsigned int flags;
};

struct dtPolyDetail
{
	unsigned int vertBase;			///< The offset of the vertices in the dtMeshTile::detailVerts array.
	unsigned int triBase;			///< The offset of the triangles in the dtMeshTile::detailTris array.
	unsigned char vertCount;		///< The number of vertices in the sub-mesh.
	unsigned char triCount;			///< The number of triangles in the sub-mesh.
    FSeek(FTell() + 4 - (FTell() % 4)); // alignment
};

struct dtBVNode
{
	unsigned short bmin[3];			///< Minimum bounds of the node's AABB. [(x, y, z)]
	unsigned short bmax[3];			///< Maximum bounds of the node's AABB. [(x, y, z)]
	int i;							///< The node's index. (Negative for escape sequence.)
};

struct dtOffMeshConnection
{
	/// The endpoints of the connection. [(ax, ay, az, bx, by, bz)]
	float pos[6];

	/// The radius of the endpoints. [Limit: >= 0]
	float rad;		

	/// The polygon reference of the connection within the tile.
	unsigned short poly;

	/// Link flags. 
	/// @note These are not the connection's user defined flags. Those are assigned via the 
	/// connection's dtPoly definition. These are link flags used for internal purposes.
	unsigned char flags;

	/// End point side.
	unsigned char side;

	/// The id of the offmesh connection. (User assigned when the navigation mesh is built.)
	unsigned int userId;

	float unk[3];
	float another_unk;
};

struct dtMeshTile(dtMeshHeader &hdr)
{
    
    struct { // might be the wrong way around idk
        float x;
        float y;
        float z;
    }verts[hdr.vertCount];

	dtPoly polys[hdr.polyCount];		///< The tile polygons. [Size: dtMeshHeader::polyCount]
	int unk[hdr.sth_per_poly * hdr.polyCount];
	dtLink links[hdr.maxLinkCount];						///< The tile links. [Size: dtMeshHeader::maxLinkCount]
	dtPolyDetail detailMeshes[hdr.detailMeshCount]<optimize=false>;			///< The tile's detail sub-meshes. [Size: dtMeshHeader::detailMeshCount]
	
	/// The detail mesh's unique vertices. [(x, y, z) * dtMeshHeader::detailVertCount]
    if (hdr.detailVertCount)
	    float detailVerts[hdr.detailVertCount * 3];	

	/// The detail mesh's triangles. [(vertA, vertB, vertC, triFlags) * dtMeshHeader::detailTriCount].
	/// See dtDetailTriEdgeFlags and dtGetDetailTriEdgeFlags.
    if (hdr.detailTriCount)
	    unsigned char detailTris[hdr.detailTriCount * 4];	

	/// The tile bounding volume nodes. [Size: dtMeshHeader::bvNodeCount]
	/// (Will be null if bounding volumes are disabled.)
    if (hdr.bvNodeCount)
	    dtBVNode bvTree[hdr.bvNodeCount];

    if (hdr.offMeshConCount)
	    dtOffMeshConnection offMeshCons[hdr.offMeshConCount];		///< The tile off-mesh connections. [Size: dtMeshHeader::offMeshConCount]
};



struct NavMeshTileHeader
{
	dtTileRef tileRef;
	int dataSize;
};